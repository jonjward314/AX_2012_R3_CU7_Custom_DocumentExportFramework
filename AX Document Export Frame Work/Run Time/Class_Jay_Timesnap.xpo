Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Jay_Timesnap unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Jay_Timesnap
    PROPERTIES
      Name                #Jay_Timesnap
      Origin              #{59B5BDDE-FF16-4922-9FD6-FB0BD2A02185}
    ENDPROPERTIES
    
    METHODS
      SOURCE #classDeclaration
        #/**************************************************************************************************************
        # * Class: Jay_Timesnap
        # * Project: Jay_UniversalExportFramework
        # * Author: Jon Ward / Jayco IT
        # * Created: (auto-generated under Jayco_Doc_Architect_Protocol_v2.0)
        # * SR#: PENDING
        # *
        # * Purpose:
        # * Utility class providing standardized 30-minute “snap” logic for aligning export windows
        # * to deterministic time boundaries. Used by Production and Historical enqueuers
        # * (e.g., Jay_ProductionBatchEnqueuer, Jay_HistoricBatchEnqueuer)
        # * to ensure consistent batch time segmentation.
        # *
        # * Environment:
        # * RunOn = Server
        # *
        # * Related Classes:
        # *  • Jay_ProductionBatchEnqueuer  – uses next30MinMark() for forward window.
        # *  • Jay_HistoricBatchEnqueuer    – may use prev30MinMark() for historical backfill.
        # *  • Jay_DocExportCtrlWorker      – aligns control records to snapped UTC intervals.
        # *
        # * Methods:
        # *  next30MinMark() → Returns next snapped half-hour mark from current UTC time.
        # *  prev30MinMark() → Returns previous snapped half-hour mark from current UTC time.
        # *
        # * Notes:
        # *  • Operates in UTC to maintain system-wide temporal consistency.
        # *  • Designed for integration with batch jobs scheduled every 30 minutes.
        # *  • Safe for reuse in other time-windowed frameworks.
        # **************************************************************************************************************/
        #class Jay_Timesnap
        #{
        #}
      ENDSOURCE
      SOURCE #currentMark
        #/// summary
        #/// Returns the CURRENT snapped boundary based on DocQueueCadenceMin().
        #/// end summary
        #public static utcDateTime currentMark()
        #{
        #    int cadenceMin  = Jay_ExportRuntimeSettings::docQueueCadenceMin();
        #    utcDateTime now = DateTimeUtil::utcNow();
        #    TimeOfDay   tod = DateTimeUtil::time(now);
        #    int minutes     = tod div 60;
        #    int currentMark = (minutes div cadenceMin) * cadenceMin;
        #
        #    return DateTimeUtil::newDateTime(
        #        DateTimeUtil::date(now),
        #        currentMark * 60,
        #        0
        #    );
        #}
      ENDSOURCE
      SOURCE #next30MinMark
        #public static utcDateTime next30MinMark()
        #{
        #    utcDateTime  now;
        #    TimeOfDay    tod;        // seconds since midnight
        #    int          minutes;    // minutes since midnight
        #    int          nextMark;   // target boundary in minutes
        #    date         thisDay;
        #    utcDateTime  snapped;
        #
        #    now      = DateTimeUtil::utcNow();
        #    tod      = DateTimeUtil::time(now);
        #    minutes  = tod div 60;
        #    nextMark = (((minutes div 30) + 1) * 30);
        #
        #    // Handle midnight rollover (e.g. 23:45 → next day 00:00)
        #    if (nextMark >= 1440) // 1440 minutes = 24 hours
        #    {
        #        thisDay = DateTimeUtil::date(DateTimeUtil::addDays(now, 1));
        #        nextMark = 0; // midnight
        #    }
        #    else
        #    {
        #        thisDay = DateTimeUtil::date(now);
        #    }
        #
        #    snapped = DateTimeUtil::newDateTime(thisDay, nextMark * 60, 0);
        #
        #    return snapped;
        #}
      ENDSOURCE
      SOURCE #nextMark
        #/// summary
        #/// Returns the next snapped time boundary based on DocQueueCadenceMin(),
        #/// not hard-coded 30.
        #/// summary
        #public static utcDateTime nextMark()
        #{
        #    int cadenceMin  = Jay_ExportRuntimeSettings::docQueueCadenceMin();
        #    utcDateTime now = DateTimeUtil::utcNow();
        #    TimeOfDay   tod = DateTimeUtil::time(now);
        #    int minutes     = tod div 60;
        #    int nextMark    = (((minutes div cadenceMin) + 1) * cadenceMin);
        #
        #    if (nextMark >= 1440) // cross midnight
        #    {
        #        return DateTimeUtil::newDateTime(
        #            DateTimeUtil::date(DateTimeUtil::addDays(now, 1)),
        #            0,
        #            0
        #        );
        #    }
        #
        #    return DateTimeUtil::newDateTime(
        #        DateTimeUtil::date(now),
        #        nextMark * 60,
        #        0
        #    );
        #}
        #
        #
      ENDSOURCE
      SOURCE #prev30MinMark
        #public static utcDateTime prev30MinMark()
        #{
        #    utcDateTime  now;
        #    TimeOfDay    tod;        // seconds since midnight
        #    int          minutes;    // minutes since midnight
        #    int          prevMark;   // target boundary in minutes
        #    date         thisDay;
        #    utcDateTime  snapped;
        #
        #    now      = DateTimeUtil::utcNow();
        #    tod      = DateTimeUtil::time(now);
        #    minutes  = tod div 60;
        #    prevMark = ((minutes div 30) * 30); // snap back to current or previous 30 block
        #
        #    thisDay  = DateTimeUtil::date(now);
        #    snapped  = DateTimeUtil::newDateTime(thisDay, prevMark * 60, 0);
        #
        #    return snapped;
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
