Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Jay_EnqueueWorker unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Jay_EnqueueWorker
    PROPERTIES
      Name                #Jay_EnqueueWorker
      Origin              #{5D80DC6A-AAF9-413A-8262-A09DFB38C2C3}
    ENDPROPERTIES
    
    METHODS
      SOURCE #classDeclaration
        #/// =================================================================================================
        #/// CLASS: Jay_EnqueueWorker
        #/// PROJECT: Jay_DocExportFramework
        #/// AUTHOR: Ward, Jonathon
        #/// CREATED: (auto-generated; update on check-in)
        #/// SR#: PENDING
        #///
        #/// PURPOSE:
        #///     Central dispatcher and document enqueuer for all exportable business objects.
        #///     Evaluates control record directives, slices by time window, and routes data
        #///     into appropriate Production or Historical queue tables.
        #///
        #/// ROLE IN FRAMEWORK:
        #///     - Interprets Jay_DocExport_CtrlTbl records created by batch enqueuers.
        #///     - Performs segmented enqueue operations (30-minute slices) per control record.
        #///     - Avoids duplicate enqueues through safeEnqueue() logic.
        #///     - Populates Jay_DocExportProdQueue / Jay_DocExportHistQueue with relevant document RecIds.
        #///
        #/// ASSOCIATED OBJECTS:
        #///     TABLES: Jay_DocExport_CtrlTbl, Jay_DocExportProdQueue, Jay_DocExportHistQueue,
        #///              SalesTable, CustConfirmJour, CustInvoiceJour, VendPurchOrderJour, AMDeviceTable
        #///     ENUMS: Jay_DocExportDocType, Jay_DocExportDocSubType, Jay_DocExportCtrlStatus, Jay_DocExportQueuePriority
        #///     CLASSES: Jay_DocExportCtrlWorker, Jay_QueueProcessorBatch
        #///
        #/// TRANSACTION NOTES:
        #///     - All write operations use ttsBegin/ttsCommit for isolation and rollback safety.
        #///     - No nested transactions; failures are isolated to per-record operations.
        #///
        #/// EXECUTION CONTEXT:
        #///     RunOn: Server
        #///     Triggered by Jay_HistoricBatchEnqueuer or Jay_ProductionBatchEnqueuer.
        #/// =================================================================================================
        #public class Jay_EnqueueWorker
        #{
        #    // Set RunOn = Server in AOT
        #}
        #
      ENDSOURCE
      SOURCE #enqueueCertificateOfOrigin
        #/// <summary>
        #/// Enqueue Certificates of Origin.
        #/// Filters SalesTable → AMDeviceTable → AMDeviceTableMaster (BodyId in MHA/MHB/MHC).
        #/// Slices by ModifiedDateTime, only if production date has been reached.
        #/// Uses SalesTable.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueCertificateOfOrigin(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                              utcDateTime _fromUtc,
        #                                              utcDateTime _toUtc
        #                                              )
        #{
        #    SalesTable          st;
        #    AMDeviceTable       d;
        #    AMDeviceTableMaster e;
        #    guid batchGuid = newGuid();
        #    date fromDate = DateTimeUtil::date(_fromUtc);
        #
        #
        #    while select st
        #        where st.SalesStatus       == SalesStatus::Invoiced
        #          && st.AMDeviceId         != ''
        #          && st.DataAreaId         == curext()
        #          && st.ModifiedDateTime  >= _fromUtc
        #          && st.ModifiedDateTime  <  _toUtc
        #        join firstOnly d
        #            where d.DeviceId == st.AMDeviceId
        #              && d.DEL_PRODUCTIONDATE >= fromDate
        #        join firstOnly e
        #            where e.MasterId == d.MasterId
        #              && (e.BodyId == 'MHA' || e.BodyId == 'MHB' || e.BodyId == 'MHC')
        #    {
        #        // enqueue once per SalesTable
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, st.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::CertificateOfOrigin, Jay_DocExportDocSubType::All, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueConfirmation
        #/// <summary>
        #/// Entry point: enqueue confirmations by subtype.
        #/// </summary>
        #public static void enqueueConfirmation(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                       utcDateTime _fromUtc,
        #                                       utcDateTime _toUtc)
        #{
        #    switch (_ctrlRecord.ExportDocSubType)
        #    {
        #        case Jay_DocExportDocSubType::Unit:
        #            Jay_EnqueueWorker::enqueueConfirmations_Unit(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::Part:
        #            Jay_EnqueueWorker::enqueueConfirmations_Parts(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::Vendor:
        #            Jay_EnqueueWorker::enqueueConfirmations_Vendor(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::All:
        #            Jay_EnqueueWorker::enqueueConfirmations_Unit(_ctrlRecord, _fromUtc, _toUtc);
        #            Jay_EnqueueWorker::enqueueConfirmations_Parts(_ctrlRecord, _fromUtc, _toUtc);
        #            Jay_EnqueueWorker::enqueueConfirmations_Vendor(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        default:
        #            warning(strFmt("⚠ No handler implemented for Confirmation SubType=%1", _ctrlRecord.ExportDocSubType));
        #            break;
        #    }
        #}
      ENDSOURCE
      SOURCE #enqueueConfirmations_Parts
        #/// <summary>
        #/// Enqueue Parts confirmations.
        #/// Filters CustGroup for Internal/Part/Part_DPU, excluding Internal+Unit shipping.
        #/// Uses CustConfirmJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueConfirmations_Parts(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                              utcDateTime _fromUtc,
        #                                              utcDateTime _toUtc)
        #{
        #    CustConfirmJour confirmJour;
        #    guid batchGuid = newGuid();
        #
        #    while select confirmJour
        #        where confirmJour.DataAreaId == curext()
        #           && ((confirmJour.CreatedDateTime  >= _fromUtc
        #                && confirmJour.CreatedDateTime <= _toUtc)
        #             || (confirmJour.ModifiedDateTime >= _fromUtc
        #                && confirmJour.ModifiedDateTime <= _toUtc))
        #           && (confirmJour.CustGroup == 'Internal'
        #            || confirmJour.CustGroup == 'Part'
        #            || confirmJour.CustGroup == 'Part_DPU')
        #           && !((confirmJour.CustGroup == 'Internal')
        #             && confirmJour.MCASHIPPINGINSTRUCTIONS == 'Unit')
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, confirmJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Confirmation, Jay_DocExportDocSubType::Part, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueConfirmations_Unit
        #public static void enqueueConfirmations_Unit(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                              utcDateTime _fromUtc,
        #                                              utcDateTime _toUtc)
        #{
        #    CustConfirmJour confirmJour;
        #    guid batchGuid = newGuid();
        #
        #    while select confirmJour
        #        where (
        #                  confirmJour.CustGroup == 'Unit'
        #               || confirmJour.CustGroup == 'Unit_PO'
        #               || (confirmJour.CustGroup == 'Internal'
        #                   && confirmJour.MCASHIPPINGINSTRUCTIONS == 'Unit')
        #              )
        #           && (
        #                  (confirmJour.CreatedDateTime  >= _fromUtc
        #                   && confirmJour.CreatedDateTime <= _toUtc)
        #               || (confirmJour.ModifiedDateTime >= _fromUtc
        #                   && confirmJour.ModifiedDateTime <= _toUtc)
        #              )
        #           && confirmJour.DataAreaId == curext()
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, confirmJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Confirmation, Jay_DocExportDocSubType::Unit, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueConfirmations_Vendor
        #/// <summary>
        #/// Enqueue Vendor confirmations.
        #/// Filters CustGroup = Vendor.
        #/// Uses CustConfirmJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueConfirmations_Vendor(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                               utcDateTime _fromUtc,
        #                                               utcDateTime _toUtc)
        #{
        #    CustConfirmJour confirmJour;
        #    guid batchGuid = newGuid();
        #
        #    while select confirmJour
        #        where confirmJour.DataAreaId == curext()
        #           && confirmJour.CustGroup == 'Vendor'
        #           && ((confirmJour.CreatedDateTime  >= _fromUtc
        #                && confirmJour.CreatedDateTime <= _toUtc)
        #             || (confirmJour.ModifiedDateTime >= _fromUtc
        #                && confirmJour.ModifiedDateTime <= _toUtc))
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, confirmJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Confirmation, Jay_DocExportDocSubType::Vendor, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueController
        #/// <summary>
        #/// Enqueues documents based on control record.
        #/// Slices window into 30-min intervals (except where day-based).
        #/// Updates CtrlStatus and increments attempts.
        #/// </summary>
        #public static Jay_DocExportCtrlStatus enqueueController(RecId _controllerRecId)
        #{
        #    int intervalMinutes = Jay_ExportRuntimeSettings::docQueueCadenceMin(); // read from settings
        #    utcDateTime     cursorStart, cursorEnd;
        #    Jay_DocExport_CtrlTbl ctrlRecord;
        #
        #    try
        #    {
        #        ctrlRecord = Jay_DocExportCtrlWorker::retrieve(_controllerRecId);
        #        Jay_DocExportCtrlWorker::updateStatus(ctrlRecord.RecId,Jay_DocExportCtrlStatus::Enqueueing);
        #        cursorStart = ctrlRecord.ExportFromUtc;
        #        cursorEnd   = DateTimeUtil::addMinutes(cursorStart, intervalMinutes);
        #
        #        while (cursorStart < ctrlRecord.ExportToUtc)
        #        {
        #            if (cursorEnd > ctrlRecord.ExportToUtc)
        #            {
        #                cursorEnd = ctrlRecord.ExportToUtc;
        #            }
        #
        #            switch (ctrlRecord.ExportDocType)
        #            {
        #                case Jay_DocExportDocType::CertificateOfOrigin:
        #                    Jay_EnqueueWorker::enqueueCertificateOfOrigin(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                case Jay_DocExportDocType::Confirmation:
        #                    Jay_EnqueueWorker::enqueueConfirmation(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                case Jay_DocExportDocType::Invoice:
        #                    Jay_EnqueueWorker::enqueueInvoices(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                case Jay_DocExportDocType::MSRP:
        #                    Jay_EnqueueWorker::enqueueMSRP(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                case Jay_DocExportDocType::PurchaseOrder:
        #                    Jay_EnqueueWorker::enqueuePurchaseOrders(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                case Jay_DocExportDocType::All:
        #                    Jay_EnqueueWorker::enqueueCertificateOfOrigin(ctrlRecord, cursorStart, cursorEnd);
        #                    Jay_EnqueueWorker::enqueueConfirmation(ctrlRecord, cursorStart, cursorEnd);
        #                    Jay_EnqueueWorker::enqueueInvoices(ctrlRecord, cursorStart, cursorEnd);
        #                    Jay_EnqueueWorker::enqueueMSRP(ctrlRecord, cursorStart, cursorEnd);
        #                    Jay_EnqueueWorker::enqueuePurchaseOrders(ctrlRecord, cursorStart, cursorEnd);
        #                    break;
        #
        #                default:
        #                    warning(strFmt("Unsupported ExportDocType %1", ctrlRecord.ExportDocType));
        #                    break;
        #            }
        #
        #            cursorStart = cursorEnd;
        #            cursorEnd   = DateTimeUtil::addMinutes(cursorStart, intervalMinutes);
        #        }
        #
        #        // ✅ Mark as complete and increment attempts
        #        ttsBegin;
        #            select forUpdate ctrlRecord
        #                where ctrlRecord.RecId == _controllerRecId;
        #            if (ctrlRecord)
        #            {
        #                ctrlRecord.ExportAttempts++;
        #                ctrlRecord.CtrlStatus = Jay_DocExportCtrlStatus::EnqueueComplete;
        #                ctrlRecord.update();
        #            }
        #        ttsCommit;
        #    }
        #    catch (Exception::Error)
        #    {
        #        error(strFmt("EnqueueController failed for CtrlRecId %1", _controllerRecId));
        #
        #        // ❌ Mark as failed and increment attempts
        #        ttsBegin;
        #            select forUpdate ctrlRecord
        #                where ctrlRecord.RecId == _controllerRecId;
        #            if (ctrlRecord)
        #            {
        #                ctrlRecord.ExportAttempts++;
        #                ctrlRecord.CtrlStatus = Jay_DocExportCtrlStatus::Failed;
        #                ctrlRecord.update();
        #            }
        #        ttsCommit;
        #    }
        #    Jay_DocExportCtrlWorker::updateStatus(ctrlRecord.RecId,Jay_DocExportCtrlStatus::EnqueueComplete);
        #    return ctrlRecord.CtrlStatus;
        #}
        #
      ENDSOURCE
      SOURCE #enqueueInvoices
        #/// <summary>
        #/// Dispatch invoices by subtype.
        #/// </summary>
        #public static void enqueueInvoices(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                   utcDateTime _fromUtc,
        #                                   utcDateTime _toUtc)
        #{
        #    switch (_ctrlRecord.ExportDocSubType)
        #    {
        #        case Jay_DocExportDocSubType::Unit:
        #            Jay_EnqueueWorker::enqueueInvoices_Unit(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::Part:
        #            Jay_EnqueueWorker::enqueueInvoices_Parts(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::Vendor:
        #            Jay_EnqueueWorker::enqueueInvoices_Vendor(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        case Jay_DocExportDocSubType::All:
        #            Jay_EnqueueWorker::enqueueInvoices_Unit(_ctrlRecord, _fromUtc, _toUtc);
        #            Jay_EnqueueWorker::enqueueInvoices_Parts(_ctrlRecord, _fromUtc, _toUtc);
        #            Jay_EnqueueWorker::enqueueInvoices_Vendor(_ctrlRecord, _fromUtc, _toUtc);
        #            break;
        #
        #        default:
        #            warning(strFmt("⚠ No handler implemented for Invoice SubType=%1", _ctrlRecord.ExportDocSubType));
        #            break;
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueInvoices_Parts
        #/// <summary>
        #/// Enqueue Parts invoices.
        #/// Filters CustGroup for Part/Part_DPU or Internal with empty BrandId.
        #/// Uses CustInvoiceJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueInvoices_Parts(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                         utcDateTime _fromUtc,
        #                                         utcDateTime _toUtc)
        #{
        #    CustInvoiceJour invoiceJour;
        #    guid batchGuid = newGuid();
        #
        #    while select invoiceJour
        #        where invoiceJour.DataAreaId == curext()
        #           && (
        #                  (invoiceJour.CreatedDateTime  >= _fromUtc && invoiceJour.CreatedDateTime <= _toUtc)
        #               || (invoiceJour.ModifiedDateTime >= _fromUtc && invoiceJour.ModifiedDateTime <= _toUtc)
        #              )
        #           && (
        #                  invoiceJour.CustGroup == 'Part'
        #               || invoiceJour.CustGroup == 'Part_DPU'
        #               || (invoiceJour.CustGroup == 'Internal' && invoiceJour.MCAAMDEVICEBRANDID == '')
        #              )
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, invoiceJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Invoice, Jay_DocExportDocSubType::Part, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueInvoices_Unit
        #/// <summary>
        #/// Enqueue Unit invoices.
        #/// Filters CustGroup for Unit/Unit_PO or Internal with BrandId set.
        #/// Uses CustInvoiceJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueInvoices_Unit(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                        utcDateTime _fromUtc,
        #                                        utcDateTime _toUtc)
        #{
        #    CustInvoiceJour invoiceJour;
        #    guid batchGuid = newGuid();
        #
        #    while select invoiceJour
        #        where invoiceJour.DataAreaId == curext()
        #           && (
        #                  (invoiceJour.CreatedDateTime  >= _fromUtc && invoiceJour.CreatedDateTime <= _toUtc)
        #               || (invoiceJour.ModifiedDateTime >= _fromUtc && invoiceJour.ModifiedDateTime <= _toUtc)
        #              )
        #           && (
        #                  invoiceJour.CustGroup == 'Unit'
        #               || invoiceJour.CustGroup == 'Unit_PO'
        #               || (invoiceJour.CustGroup == 'Internal' && invoiceJour.MCAAMDEVICEBRANDID != '')
        #              )
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, invoiceJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Invoice, Jay_DocExportDocSubType::Unit, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueInvoices_Vendor
        #/// <summary>
        #/// Enqueue Vendor invoices.
        #/// Filters CustGroup = Vendor.
        #/// Uses CustInvoiceJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueInvoices_Vendor(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                          utcDateTime _fromUtc,
        #                                          utcDateTime _toUtc)
        #{
        #    CustInvoiceJour invoiceJour;
        #    guid batchGuid = newGuid();
        #
        #    while select invoiceJour
        #        where invoiceJour.DataAreaId == curext()
        #           && (
        #                  (invoiceJour.CreatedDateTime  >= _fromUtc && invoiceJour.CreatedDateTime <= _toUtc)
        #               || (invoiceJour.ModifiedDateTime >= _fromUtc && invoiceJour.ModifiedDateTime <= _toUtc)
        #              )
        #           && invoiceJour.CustGroup == 'Vendor'
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, invoiceJour.RecId,'','','','', _fromUtc, _toUtc, Jay_DocExportDocType::Invoice, Jay_DocExportDocSubType::Vendor, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueueMSRP
        #/// <summary>
        #/// Enqueue MSRP sheets.
        #/// Filters SalesTable → AMDeviceTable.
        #/// Slices by ModifiedDateTime, only if production date has been reached.
        #/// Uses SalesTable.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueueMSRP(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                               utcDateTime _fromUtc,
        #                               utcDateTime _toUtc)
        #{
        #    SalesTable    st;
        #    AMDeviceTable d;
        #    guid batchGuid = newGuid();
        #
        #    date fromDate = DateTimeUtil::date(_fromUtc);
        #
        #    while select st
        #        where st.SalesStatus       == SalesStatus::Invoiced
        #          && st.AMDeviceId         != ''
        #          && st.DataAreaId         == curext()
        #          && st.ModifiedDateTime  >= _fromUtc
        #          && st.ModifiedDateTime  <  _toUtc
        #        join firstOnly d
        #            where d.DeviceId == st.AMDeviceId
        #              && d.DEL_PRODUCTIONDATE >= fromDate
        #    {
        #        // enqueue at SalesTable level
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, st.RecId,st.SalesId, d.DeviceId,'','', _fromUtc, _toUtc, Jay_DocExportDocType::MSRP,Jay_DocExportDocSubType::All, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #enqueuePurchaseOrders
        #/// <summary>
        #/// Enqueue Purchase Orders.
        #/// Joins VendPurchOrderJour → PurchTable for Created/ModifiedDateTime.
        #/// Filters by PurchOrderDate (business cutoff) + DateTime slice (granularity).
        #/// Uses VendPurchOrderJour.RecId as SourceRecId.
        #/// </summary>
        #public static void enqueuePurchaseOrders(Jay_DocExport_CtrlTbl _ctrlRecord,
        #                                         utcDateTime _fromUtc,
        #                                         utcDateTime _toUtc)
        #{
        #    VendPurchOrderJour purchJour;
        #    PurchTable         purchTable;
        #    guid batchGuid = newGuid();
        #
        #    date fromDate = DateTimeUtil::date(_fromUtc);
        #
        #    while select purchJour
        #    where purchJour.DataAreaId == curext()
        #      && (
        #             (purchJour.CreatedDateTime  >= _fromUtc
        #              && purchJour.CreatedDateTime <= _toUtc)
        #          || (purchJour.ModifiedDateTime >= _fromUtc
        #              && purchJour.ModifiedDateTime <= _toUtc)
        #         )
        #    join purchTable
        #        where purchTable.PurchId    == purchJour.PurchId
        #          && purchTable.DataAreaId == purchJour.DataAreaId
        #    {
        #        Jay_EnqueueWorker::safeEnqueue(_ctrlRecord, purchJour.RecId,purchJour.PurchId,'','','', _fromUtc, _toUtc, Jay_DocExportDocType::PurchaseOrder,Jay_DocExportDocSubType::All, batchGuid);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #safeEnqueue
        #/// <summary>
        #/// Safely inserts or refreshes queue entries without duplication.
        #/// Enforces uniqueness per SourceRecId and time window.
        #/// Handles both Production and Historical queue modes.
        #/// Supports secondary through quinary reference identifiers.
        #/// <param name="_ctrlRecord">Control table record driving the enqueue.</param>
        #/// <param name="_sourceRecId">Primary source record RecId (e.g., SalesTable.RecId).</param>
        #/// <param name="_secondaryIdent">Optional secondary identifier (string key).</param>
        #/// <param name="_tertiaryIdent">Optional tertiary identifier.</param>
        #/// <param name="_quaternaryIdent">Optional quaternary identifier.</param>
        #/// <param name="_quinaryIdent">Optional quinary identifier.</param>
        #/// <param name="_fromUtc">UTC lower bound of export window.</param>
        #/// <param name="_toUtc">UTC upper bound of export window.</param>
        #/// <param name="_documentType">Document type (Confirmation, Invoice, etc.).</param>
        #/// <param name="_documentSubType">Document subtype (if applicable).</param>
        #/// <param name="_batchGuid">Unique GUID tag for this enqueue batch.</param>
        #/// </summary>
        #public static void safeEnqueue(
        #    Jay_DocExport_CtrlTbl    _ctrlRecord,
        #    RecId                    _sourceRecId,
        #    str                      _secondaryIdent,
        #    str                      _tertiaryIdent,
        #    str                      _quaternaryIdent,
        #    str                      _quinaryIdent,
        #    utcDateTime              _fromUtc,
        #    utcDateTime              _toUtc,
        #    Jay_DocExportDocType     _documentType,
        #    Jay_DocExportDocSubType  _documentSubType,
        #    guid                     _batchGuid
        #    )
        #{
        #    Jay_DocExportProdQueue pq;
        #    Jay_DocExportHistQueue hq;
        #    utcDateTime nowUtc = DateTimeUtil::utcNow();
        #
        #    // ---------------------------
        #    // Production Queue Handling
        #    // ---------------------------
        #    if (_ctrlRecord.ExportPriority == Jay_DocExportQueuePriority::Production)
        #    {
        #        select firstOnly forUpdate pq
        #            where pq.ExportDocType    == _documentType
        #              && pq.ExportDocSubType == _documentSubType
        #              && pq.SourceRecId      == _sourceRecId;
        #
        #        if (!pq)
        #        {
        #            // brand new → insert
        #            ttsBegin;
        #                pq.clear();
        #                pq.ExportDocType         = _documentType;
        #                pq.ExportDocSubType      = _documentSubType;
        #                pq.ExportAttempts        = 0;
        #                pq.ExportFromUtc         = _fromUtc;
        #                pq.ExportToUtc           = _toUtc;
        #                pq.QueueStatus           = Jay_DocExportQueueStatus::Queued;
        #                pq.OrigQueueTime         = nowUtc;
        #                pq.LastAttemptedDateTime = DateTimeUtil::minValue();
        #                pq.SourceRecId           = _sourceRecId;
        #                pq.RefId1                = _secondaryIdent;
        #                pq.RefId2                = _tertiaryIdent;
        #                pq.RefId3                = _quaternaryIdent;
        #                pq.RefId4                = _quinaryIdent;
        #                pq.CtrlRecId             = _ctrlRecord.RecId;
        #                pq.BatchTag              = _batchGuid;
        #                pq.PrintDelay            = _ctrlRecord.PrintDelay;
        #                pq.insert();
        #            ttsCommit;
        #        }
        #        else
        #        {
        #            // safeguard: only reset if last enqueue predates this window
        #            if (pq.ModifiedDateTime < _fromUtc)
        #            {
        #                ttsBegin;
        #                    pq.ExportAttempts        = 0;
        #                    pq.QueueStatus           = Jay_DocExportQueueStatus::Queued;
        #                    pq.OrigQueueTime         = nowUtc;
        #                    pq.LastAttemptedDateTime = DateTimeUtil::minValue();
        #                    pq.CtrlRecId             = _ctrlRecord.RecId;
        #                    pq.BatchTag              = _batchGuid;
        #                    pq.PrintDelay            = _ctrlRecord.PrintDelay;
        #                    pq.ExportFromUtc         = _fromUtc;
        #                    pq.ExportToUtc           = _toUtc;
        #                    pq.RefId1                = _secondaryIdent;
        #                    pq.RefId2                = _tertiaryIdent;
        #                    pq.RefId3                = _quaternaryIdent;
        #                    pq.RefId4                = _quinaryIdent;
        #                    pq.update();
        #                ttsCommit;
        #            }
        #            // else: this record was already queued during this window → skip
        #        }
        #    }
        #    // ---------------------------
        #    // Historical Queue Handling
        #    // ---------------------------
        #    else if (_ctrlRecord.ExportPriority == Jay_DocExportQueuePriority::Historical)
        #    {
        #        select firstOnly forUpdate hq
        #            where hq.ExportDocType    == _documentType
        #              && hq.ExportDocSubType == _documentSubType
        #              && hq.SourceRecId      == _sourceRecId;
        #
        #        if (!hq)
        #        {
        #            // brand new historical insert
        #            ttsBegin;
        #                hq.clear();
        #                hq.ExportDocType         = _documentType;
        #                hq.ExportDocSubType      = _documentSubType;
        #                hq.ExportAttempts        = 0;
        #                hq.ExportFromUtc         = _fromUtc;
        #                hq.ExportToUtc           = _toUtc;
        #                hq.QueueStatus           = Jay_DocExportQueueStatus::Queued;
        #                hq.OrigQueueTime         = nowUtc;
        #                hq.LastAttemptedDateTime = DateTimeUtil::minValue();
        #                hq.SourceRecId           = _sourceRecId;
        #                hq.RefId1                = _secondaryIdent;
        #                hq.RefId2                = _tertiaryIdent;
        #                hq.RefId3                = _quaternaryIdent;
        #                hq.RefId4                = _quinaryIdent;
        #                hq.CtrlRecId             = _ctrlRecord.RecId;
        #                hq.PrintDelay            = _ctrlRecord.PrintDelay;
        #                hq.BatchTag              = _batchGuid;
        #                hq.insert();
        #            ttsCommit;
        #        }
        #        else
        #        {
        #            // historical normally refreshes row regardless
        #            ttsBegin;
        #                hq.ExportAttempts        = 0;
        #                hq.QueueStatus           = Jay_DocExportQueueStatus::Queued;
        #                hq.OrigQueueTime         = nowUtc;
        #                hq.LastAttemptedDateTime = DateTimeUtil::minValue();
        #                hq.CtrlRecId             = _ctrlRecord.RecId;
        #                hq.PrintDelay            = _ctrlRecord.PrintDelay;
        #                hq.BatchTag              = _batchGuid;
        #                hq.ExportFromUtc         = _fromUtc;
        #                hq.ExportToUtc           = _toUtc;
        #                hq.RefId1                = _secondaryIdent;
        #                hq.RefId2                = _tertiaryIdent;
        #                hq.RefId3                = _quaternaryIdent;
        #                hq.RefId4                = _quinaryIdent;
        #                hq.update();
        #            ttsCommit;
        #        }
        #    }
        #}
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
