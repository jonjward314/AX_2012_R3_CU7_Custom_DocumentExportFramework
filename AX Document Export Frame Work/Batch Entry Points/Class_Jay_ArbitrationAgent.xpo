Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Jay_ArbitrationAgent unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Jay_ArbitrationAgent
    PROPERTIES
      Name                #Jay_ArbitrationAgent
      Origin              #{0810157E-15B3-49AE-B460-69BFA48EE933}
    ENDPROPERTIES
    
    METHODS
      SOURCE #caption
        #//  Caption for batch form
        #//
        #public Description caption()
        #{
        #    return this.description();
        #}
      ENDSOURCE
      SOURCE #classDeclaration
        #/**************************************************************************************************************
        # * CLASS: Jay_ArbitrationAgent
        # * PROJECT: Jay_DocExportFramework
        # * AUTHOR: Ward, Jonathon
        # *
        # * PURPOSE:
        # *  Autonomous scheduler and regulator for export job arbitration.
        # *  Now implemented as a RunBaseBatch job for recurring, hands-free execution.
        # *  Enforces print capacity, heals stalled controllers, and ensures
        # *  Historical jobs respect the configured time window.
        # *
        # * EXECUTION:
        # *  Schedule under batch group Jay_Arbitration (default every 30 minutes)
        # *
        # * BEHAVIOR:
        # *  - Resumes eligible Historical controllers when capacity allows
        # *  - Wakes Waiting controllers whose deferral expired
        # *  - Detects livelocked Processing controllers and resets them safely
        # *  - Skips Historical runs outside Jay_ExportRuntimeSettings::isWithinHistoricalWindow()
        # *
        # * RUNON: Server
        # **************************************************************************************************************/
        #class Jay_ArbitrationAgent extends RunBaseBatch
        #{
        #    #define.CurrentVersion(1)
        #    #localmacro.CurrentList
        #    #endmacro
        #
        #    Jay_ArbitrationLogLevel logLevel;
        #}
      ENDSOURCE
      SOURCE #description
        #//
        #//  Description for batch UI
        #//
        #public Description description()
        #{
        #    return "Jay Arbitration Agent (auto-healing export control resumer)";
        #}
        #
      ENDSOURCE
      SOURCE #pack
        #//
        #//  Standard RunBaseBatch packing/unpacking
        #//
        #public container pack()
        #{
        #    return [#CurrentVersion];
        #}
      ENDSOURCE
      SOURCE #reviveStaleControllers
        #//
        #//  Detect controllers stuck in Processing for too long and safely reset them.
        #//
        #private int reviveStaleControllers()
        #{
        #    Jay_DocExport_CtrlTbl ctrl;
        #    int healed;
        #    int staleMin = Jay_ExportRuntimeSettings::staleControllerMinutes();
        #    utcDateTime cutoff = DateTimeUtil::addMinutes(DateTimeUtil::utcNow(), -staleMin);
        #
        #    while select forUpdate ctrl
        #        where ctrl.CtrlStatus == Jay_DocExportCtrlStatus::Processing
        #          && ctrl.ModifiedDateTime < cutoff
        #    {
        #        Jay_ArbitrationLogger::log(
        #            ctrl.RecId, ctrl.ExportPriority,
        #            "ReviveStale",
        #            strFmt("Controller Processing > %1 min, resetting to Waiting.", staleMin));
        #
        #        ctrl.CtrlStatus = Jay_DocExportCtrlStatus::Waiting;
        #        ctrl.update();
        #        healed++;
        #    }
        #    return healed;
        #}
      ENDSOURCE
      SOURCE #run
        #//
        #//  Core batch entry point
        #//
        #public void run()
        #{
        #    utcDateTime nowUtc;
        #    boolean withinHistWin;
        #    int resumedHist = 0;
        #    int resumedWait = 0;
        #    int healedStale = 0;
        #    Jay_PrintOpsSecurity::requireRevverAdmin();
        #    logLevel = Jay_ExportRuntimeSettings::arbitrationLogLevel();
        #
        #    nowUtc = DateTimeUtil::utcNow();
        #    info(strFmt("🩺 Jay_ArbitrationAgent started @ %1", nowUtc));
        #
        #
        #
        #    // Enforce Historical window boundaries
        #    withinHistWin = Jay_ExportRuntimeSettings::isWithinHistoricalWindow(nowUtc);
        #
        #    // 1️⃣ Heal stale / livelocked controllers
        #    healedStale = this.reviveStaleControllers();
        #
        #    // 2️⃣ Resume eligible Historical controllers only within window
        #    if (withinHistWin)
        #    {
        #        resumedHist = Jay_ArbitrationAgent::resumeEligibleHistorical();
        #    }
        #    else
        #    {
        #        Jay_ArbitrationLogger::log(0, Jay_DocExportQueuePriority::Historical,
        #            "HistoricalWindowClosed",
        #            "Skipped Historical resume — outside configured time window.");
        #    }
        #
        #    // 3️⃣ Resume Waiting controllers whose delay expired
        #    resumedWait = Jay_ArbitrationAgent::resumeWaitingControllers();
        #
        #    // 4️⃣ Summary
        #    Jay_ArbitrationLogger::log(0, Jay_DocExportQueuePriority::Production,
        #        "ArbitrationSummary",
        #        strFmt("Completed @ %1 — ResumedHist:%2 ResumedWait:%3 HealedStale:%4",
        #               nowUtc, resumedHist, resumedWait, healedStale));
        #
        #    info(strFmt("✅ ArbitrationAgent finished — Hist:%1 Wait:%2 Healed:%3",
        #                resumedHist, resumedWait, healedStale));
        #}
        #
      ENDSOURCE
      SOURCE #showBatchTab
        #//
        #//  Always show Batch tab in the dialog
        #//
        #public boolean showBatchTab(boolean _set = false)
        #{
        #    return true;
        #}
      ENDSOURCE
      SOURCE #unpack
        #public boolean unpack(container _packedClass)
        #{
        #    Version version = conPeek(_packedClass,1);
        #    switch (version)
        #    {
        #        case #CurrentVersion:
        #            break;
        #        default:
        #            return false;
        #    }
        #    return true;
        #}
      ENDSOURCE
      SOURCE #main
        #//
        #//  Main launcher for manual execution
        #//
        #public static void main(Args _args)
        #{
        #    Jay_ArbitrationAgent job = new Jay_ArbitrationAgent();
        #
        #    if (job.prompt())
        #    {
        #        job.run();
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #resumeEligibleHistorical
        #
        #/// summary
        #/// Determines if printer and production capacity allow a Historical control to run,
        #/// and starts the oldest eligible one if so.
        #/// end summary
        #public static int resumeEligibleHistorical()
        #{
        #    Jay_DocExport_CtrlTbl ctrl;
        #    int counter;
        #    int remaining = Jay_PrintGovernor::remainingCapacity();
        #
        #    if (remaining <= 0)
        #    {
        #        info("⚠ Printer capacity full — no Historical runs started.");
        #        return 0;
        #    }
        #
        #    // Only resume when no Production controller is active
        #    if (Jay_DocExportCtrlWorker::countActiveProd() > 0)
        #    {
        #        info("Production active — Historical deferral continues.");
        #        return 0;
        #    }
        #
        #    // Find oldest Historical in EnqueueComplete or Waiting
        #    select firstOnly ctrl order by ctrl.CreatedDateTime asc
        #        where ctrl.ExportPriority == Jay_DocExportQueuePriority::Historical
        #          && (ctrl.CtrlStatus == Jay_DocExportCtrlStatus::EnqueueComplete ||
        #              ctrl.CtrlStatus == Jay_DocExportCtrlStatus::Waiting);
        #
        #
        #    if (ctrl.RecId)
        #    {
        #        info(strFmt("▶ Arbitration launching Historical Control %1", ctrl.RecId));
        #        Jay_HistoricalBatchIterator::processByBatchTag(ctrl.RecId);
        #        counter++;
        #    }
        #    else
        #    {
        #        info("No eligible Historical control found for arbitration.");
        #    }
        #
        #    return counter;
        #}
        #
      ENDSOURCE
      SOURCE #resumeEligibleProduction
        #public static void resumeEligibleProduction(Jay_DocExport_CtrlTbl _ctrlRecord)
        #{
        #    Jay_DocExportProdQueue prodRec;
        #    int cadenceMin        = Jay_ExportRuntimeSettings::docQueueCadenceMin();
        #    int safeThresholdMin  = cadenceMin / 5; // bottom 20% = “too risky to resume now”
        #    int64 minutesLeft       = DateTimeUtil::getDifference(
        #                                _ctrlRecord.ExportToUtc,
        #                                DateTimeUtil::utcNow()
        #                            ) / 60;
        #
        #    int maxAttempts = Jay_ExportRuntimeSettings::maxAllowedPrintAttempts();
        #
        #    // Only resume if current controller is Production
        #    if (_ctrlRecord.ExportPriority != Jay_DocExportQueuePriority::Production)
        #    {
        #        Jay_ArbitrationLogger::log(
        #            _ctrlRecord.RecId, _ctrlRecord.ExportPriority,
        #            "SkipResumeProd",
        #            "Controller is not Production — skipping production resume request."
        #        );
        #        return;
        #    }
        #
        #    // SAFETY GATE — close to next window? Abort silently / safely
        #    if (minutesLeft <= safeThresholdMin)
        #    {
        #        Jay_ArbitrationLogger::log(
        #            _ctrlRecord.RecId, _ctrlRecord.ExportPriority,
        #            "DeferToNextSlice",
        #            strFmt("Too close to next window (%1 min left ≤ %2 threshold). Safe defer.",
        #                   minutesLeft, safeThresholdMin)
        #        );
        #        return; // ✅ passive — next scheduled Prod sweep will naturally handle
        #    }
        #
        #    // 🔎 Look for orphaned QUEUED rows in SAME time slice
        #    while select firstOnly prodRec
        #        where prodRec.CtrlRecId   == _ctrlRecord.RecId
        #          && (prodRec.QueueStatus  == Jay_DocExportQueueStatus::Queued ||
        #              prodRec.QueueStatus  == Jay_DocExportQueueStatus::FailedExport ||
        #              prodRec.QueueStatus  == Jay_DocExportQueueStatus::Incomplete ||
        #              prodRec.QueueStatus  == Jay_DocExportQueueStatus::Waiting ||
        #              prodRec.QueueStatus  == Jay_DocExportQueueStatus::Processing)
        #          &&  prodRec.ExportAttempts < maxAttempts
        #          && prodRec.ExportToUtc  < _ctrlRecord.ExportFromUtc
        #    {
        #        Jay_ArbitrationLogger::log(
        #            _ctrlRecord.RecId, _ctrlRecord.ExportPriority,
        #            "ResumeProduction",
        #            strFmt("Resuming orphaned queued Prod BatchTag %1", guid2str(prodRec.BatchTag))
        #        );
        #
        #        // ✅ SAFE immediate restart — we *still have runway* in this time slice
        #        Jay_QueueProcessorBatch::start_BatchTag(
        #            _ctrlRecord.RecId,
        #            prodRec.BatchTag,
        #            _ctrlRecord.ExportPriority
        #        );
        #        return;
        #    }
        #
        #    Jay_ArbitrationLogger::log(
        #        _ctrlRecord.RecId, _ctrlRecord.ExportPriority,
        #        "NoProdResumeNeeded",
        #        "No orphaned Production rows found — skipping resume."
        #    );
        #}
      ENDSOURCE
      SOURCE #resumeWaitingControllers
        #
        #/// summary
        #/// Wakes controls stuck in CtrlStatus::Waiting if their deferral time has passed.
        #/// end summary
        #public static int resumeWaitingControllers()
        #{
        #    Jay_DocExport_CtrlTbl ctrl;
        #    int resumed;
        #    int remaining = Jay_PrintGovernor::remainingCapacity();
        #
        #    if (remaining <= 0)
        #    {
        #        info("⚠ Printer capacity full — skipping wake of Waiting controllers.");
        #        return 0;
        #    }
        #
        #    while select firstOnly ctrl
        #        where ctrl.CtrlStatus == Jay_DocExportCtrlStatus::Waiting
        #          && ctrl.ExportPriority == Jay_DocExportQueuePriority::Production
        #    {
        #        info(strFmt("Waking deferred Production control %1", ctrl.RecId));
        #        Jay_QueueProcessorBatch::start_QueueProcessor(ctrl.RecId);
        #        resumed++;
        #    }
        #
        #    return resumed;
        #}
        #
        #
      ENDSOURCE
      SOURCE #slotAvailable
        #/// summary
        #/// Returns true if there is room to start additional work (based on printer tokens).
        #/// summary
        #public static boolean slotAvailable()
        #{
        #    return (Jay_PrintGovernor::remainingCapacity() > 0);
        #}
        #
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
