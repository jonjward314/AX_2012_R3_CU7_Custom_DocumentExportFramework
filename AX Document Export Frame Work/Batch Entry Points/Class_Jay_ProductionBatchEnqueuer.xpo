Exportfile for AOT version 1.0 or later
Formatversion: 1

***Element: CLS

; Microsoft Dynamics AX Class: Jay_ProductionBatchEnqueuer unloaded
; --------------------------------------------------------------------------------
  CLSVERSION 1
  
  CLASS #Jay_ProductionBatchEnqueuer
    PROPERTIES
      Name                #Jay_ProductionBatchEnqueuer
      Extends             #RunBaseBatch
      Origin              #{C14ADE4A-6B3B-4D71-91D5-115B992CFB10}
    ENDPROPERTIES
    
    METHODS
      SOURCE #caption
        #public Description caption()
        #{
        #    return this.description();
        #}
        #
      ENDSOURCE
      SOURCE #classDeclaration
        #/// =================================================================================================
        #/// CLASS: Jay_ProductionBatchEnqueuer
        #/// PROJECT: Jay_DocExportFramework
        #/// AUTHOR: Ward, Jonathon
        #/// CREATED: (auto-generated header, update date on check-in)
        #/// SR#: PENDING
        #///
        #/// PURPOSE:
        #///     Recurring Production Enqueuer that slices time into 30-minute intervals,
        #///     determining which document control windows (Certificates of Origin, Confirmations,
        #///     Invoices, MSRP Sheets, and Purchase Orders) must be enqueued into Production queue
        #///     tables for subsequent processing by Jay_QueueProcessorBatch.
        #///
        #/// OVERVIEW:
        #///     - Runs on the server tier under Batch execution.
        #///     - Uses UTC snapping logic to align execution windows on 00/30 minute boundaries.
        #///     - Calls Jay_DocExportCtrlWorker::initialize() to establish control records.
        #///     - Invokes Jay_EnqueueWorker::enqueueController() to populate document queues.
        #///     - Automatically schedules Jay_QueueProcessorBatch when enqueue completes.
        #///     - Cleanup of expired records occurs via Jay_LogMaintenanceService::purgeExpired().
        #///
        #/// ASSOCIATED OBJECTS:
        #///     TABLES: Jay_DocExport_CtrlTbl, Jay_DocExportProdQueue, Jay_DocExportHistQueue
        #///     CLASSES: Jay_DocExportCtrlWorker, Jay_EnqueueWorker, Jay_QueueProcessorBatch, Jay_LogMaintenanceService
        #///     ENUMS: Jay_DocExportCtrlStatus, Jay_DocExportDocType, Jay_DocExportQueuePriority
        #///
        #/// TRANSACTION / LOCKING NOTES:
        #///     - No direct ttsBegin/ttsCommit blocks are used here.
        #///     - Downstream methods (Jay_DocExportCtrlWorker, Jay_EnqueueWorker) internally
        #///       handle their own transactional scope.
        #///     - All critical operations are idempotent: safe for re-execution if batch retries.
        #///
        #/// EXECUTION CONTEXT:
        #///     - RunOn: Server
        #///     - Runs under batch service account.
        #///     - Should be configured to repeat every 30 minutes.
        #///
        #/// =================================================================================================
        #class Jay_ProductionBatchEnqueuer extends RunBaseBatch
        #{
        #    RecId ctrlRecId;
        #
        #    #define.CurrentVersion(1)
        #    #localmacro.CurrentList
        #        ctrlRecId
        #    #endmacro
        #}
        #
      ENDSOURCE
      SOURCE #description
        #/// <summary>
        #/// Description shown in batch job list.
        #/// Appears in Batch Job history and forms.
        #/// </summary>
        #public Description description()
        #{
        #    utcDateTime nowUtc     = DateTimeUtil::utcNow();
        #    Timezone    userTz     = DateTimeUtil::getUserPreferredTimeZone();
        #    utcDateTime localNow   = DateTimeUtil::applyTimeZoneOffset(nowUtc, userTz);
        #    utcDateTime localStart = DateTimeUtil::applyTimeZoneOffset(
        #                                DateTimeUtil::addMinutes(nowUtc, -30),
        #                                userTz);
        #
        #    str localStartStr = DateTimeUtil::toStr(localStart);
        #    str localNowStr   = DateTimeUtil::toStr(localNow);
        #
        #    return strFmt("Production Doc Enqueuer [%1/%2 | %3 → %4]",
        #                  "All",
        #                  "All",
        #                  localStartStr,
        #                  localNowStr);
        #}
        #
      ENDSOURCE
      SOURCE #dialog
        #/// <summary>
        #/// Dialog for initial scheduling.
        #/// Displays informational text only; no runtime parameters required.
        #/// </summary>
        #    public Object dialog()
        #    {
        #        DialogRunbase dialog = super();
        #        dialog.addText("This job will always export ALL documents for the last 30 minutes, snapped to the nearest half-hour boundary. Use the Batch tab to configure recurrence (e.g., every 30 minutes).");
        #        return dialog;
        #    }
        #
      ENDSOURCE
      SOURCE #pack
        #
        #    /// <summary>
        #/// Pack method for batch persistence.
        #/// </summary>
        #    public container pack()
        #    {
        #        return [#CurrentVersion, #CurrentList];
        #    }
        #
        #
      ENDSOURCE
      SOURCE #run
        #public void run()
        #{
        #    // Phase 0: Derive snappable time window from policy, not constants
        #
        #    utcDateTime toUtc   = Jay_Timesnap::currentMark();  // snapped to runtime cadence
        #    utcDateTime fromUtc = Jay_DocExportCtrlWorker::resolveNextFromUtc(
        #        Jay_DocExportQueuePriority::Production
        #    );
        #
        #
        #    // Initialize control record
        #    RecId exportCtrlRecId = Jay_DocExportCtrlWorker::initialize(
        #        Jay_DocExportDocType::All,
        #        Jay_DocExportDocSubType::All,
        #        fromUtc,
        #        toUtc,
        #        Jay_DocExportQueuePriority::Production
        #    );
        #
        #    // Pull control record for routing
        #    Jay_DocExport_CtrlTbl ctrlRecord;
        #    Jay_DocExportCtrlStatus ctrlStatus;
        #
        #    select firstOnly ctrlRecord where ctrlRecord.RecId == exportCtrlRecId;
        #
        #
        #
        #    // ----------------------------------------------------------------------
        #    // Dispatch by ExportStage
        #    // ----------------------------------------------------------------------
        #    switch (ctrlRecord.ExportRuntime)
        #    {
        #        case Jay_DocExportRuntimeMode::SafeDeterministic: // or 0 if enum not yet created
        #            ctrlStatus = Jay_EnqueueWorker::enqueueController(exportCtrlRecId);
        #            break;
        #
        #        case Jay_DocExportRuntimeMode::FastRecoverable: // or 1
        #            ctrlStatus = Jay_enStageWorker::enStageController(exportCtrlRecId);
        #            break;
        #
        #        default:
        #            ctrlStatus = Jay_enStageWorker::enStageController(exportCtrlRecId);
        #            break;
        #    }
        #
        #    // ----------------------------------------------------------------------
        #    // Handle post-enqueue with policy boundary
        #    // ----------------------------------------------------------------------
        #    if (ctrlStatus == Jay_DocExportCtrlStatus::EnqueueComplete)
        #    {
        #        if (Jay_PrintOpsSecurity::isRevverAdmin())
        #        {
        #            Jay_QueueProcessorBatch::start_QueueProcessor(exportCtrlRecId);
        #            info(strFmt("✅ Processor batch scheduled for export %1", exportCtrlRecId));
        #        }
        #        else
        #        {
        #            info(strFmt("ℹ Enqueue complete for %1, but processor not scheduled due to policy. A RevverAdmin must start the Queue Processor.", exportCtrlRecId));
        #        }
        #    }
        #    else
        #    {
        #        error(strFmt("Export %1 failed with status %2", exportCtrlRecId, enum2str(ctrlStatus)));
        #        Jay_DocExportCtrlWorker::updateStatus(exportCtrlRecId, Jay_DocExportCtrlStatus::Failed);
        #    }
        #}
        #
      ENDSOURCE
      SOURCE #showBatchTab
        #
        #/// <summary>
        #/// Always show batch tab for recurrence setup.
        #/// </summary>
        #    public boolean showBatchTab(boolean _set = false)
        #    {
        #        return true;
        #    }
        #
        #
      ENDSOURCE
      SOURCE #unpack
        #   /// <summary>
        #    /// Unpack
        #    /// </summary>
        #    public boolean unpack(container _packedClass)
        #    {
        #        Version version = conPeek(_packedClass, 1);
        #
        #        switch (version)
        #        {
        #            case #CurrentVersion:
        #                [version, #CurrentList] = _packedClass;
        #                break;
        #            default:
        #                return false;
        #        }
        #        return true;
        #    }
        #
      ENDSOURCE
      SOURCE #main
        #/// <summary>
        #/// Unpack method for batch deserialization.
        #/// </summary>
        #    public static void main(Args _args)
        #    {
        #        Jay_ProductionBatchEnqueuer job = new Jay_ProductionBatchEnqueuer();
        #
        #        if (job.prompt()) // initial scheduling only
        #        {
        #            // User sets recurrence in Batch tab
        #            job.run();
        #        }
        #    }
      ENDSOURCE
    ENDMETHODS
  ENDCLASS

***Element: END
